Câu 6:

    Sử dụng các thư viện cần thiết để thực hiện yêu cầu.
    Bắt đầu sử dụng các filter để thực hiện yêu cầu đề bài:

    Mean Filter: -> a = iio.imread('baby.jpeg', mode='L'): Sử dụng để python có thể đọc ảnh = grayscale. -> k = np.ones((5, 5)) / 25 : Sử dụng hàm np.ones để tạo mảng với ma trận 5x5 sau đó chia cho 25 -> b = sn.convolve(a, k).astype(np.uint8) : sử dụng sn với convolve giữa (a,k) để tính phép tích chập , sau đó sử dụng (.astype(np.uint8)) để đảm bảo giá trị của pixel nằm trong khoảng [0,255] -> iio.imsave('baby.jpeg', b) : Sử dụng để lưu lại kết quả mới nhất của ảnh sau khi ảnh đã được xử lý bởi mảng b. -> plt.imshow(b): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.title("Mean Filter") : Ghi chủ đề ảnh. -> plt.show() : Mở cửa sở để hiển thị ảnh.
    Median Filter : -> a1 = iio.imread('baby.jpeg', mode='L').astype(np.uint8): Sử dụng để python có thể đọc ảnh = grayscale ( model = L) và stype(np.uint8) để giá trị pixel [0,255]. -> b1 = sn.median_filter(a1, size=5, footprint=None, output=None, mode='reflect',cval=0.0, origin=0): Sử dụng hàm sn.median_filter để thực hiện bộ lọc trung vị với a1 là ảnh xám đầu vào, size =5 là kích thước tương ứng là 5x5 pixel, footprint = None là không sử dụng ma trận footprint , output = None là kết quả được lưu vào b1 , mode='reflect' là cách xử lý biên ảnh các pixel ngoài biên được phản chiếu , cval=0.0 là giá trị hằng, origin = 0 là điểm gốc của kernel ở trung tâm. -> iio.imsave('abc.png', b1): Lưu ảnh đã lọc -> plt.imshow(b1): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.title("Median Filter") : Ghi chủ đề ảnh. -> plt.show() : Mở cửa sở để hiển thị ảnh.
    Max filter: -> a1 = iio.imread('baby.jpeg', mode='L').astype(np.uint8): Sử dụng để python có thể đọc ảnh = grayscale ( model = L) và stype(np.uint8) để giá trị pixel [0,255]. -> b2 = sn.maxium_filter(a1, size=5, footprint=None, output=None, mode='reflect',cval=0.0, origin=0): Sử dụng hàm sn.maxium_filter để thực hiện bộ lọc có lấy giá trị lớn nhất vùng lân cận với a1 là ảnh xám đầu vào, size =5 là kích thước tương ứng là 5x5 pixel, footprint = None là không sử dụng ma trận footprint , output = None là kết quả được lưu vào b1 , mode='reflect' là cách xử lý biên ảnh các pixel ngoài biên được phản chiếu , cval=0.0 là giá trị hằng, origin = 0 là điểm gốc của kernel ở trung tâm. -> iio.imsave('abc.png', b2): Lưu ảnh đã lọc -> plt.imshow(b2): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.title("Median Filter") : Ghi chủ đề ảnh. -> plt.show() : Mở cửa sở để hiển thị ảnh.
    Min Filter:
    -> a1 = iio.imread('baby.jpeg', mode='L').astype(np.uint8): Sử dụng để python có thể đọc ảnh = grayscale ( model = L) và stype(np.uint8) để giá trị pixel [0,255]. -> b3 = sn.minimum_filter(a1, size=5, footprint=None, output=None,mode='reflect',cval=0.0, origin=0): Sử dụng hàm sn.minimum_filter để thực hiện bộ lọc có lấy giá trị nhỏ nhất vùng lân cận với a1 là ảnh xám đầu vào, size =5 là kích thước tương ứng là 5x5 pixel, footprint = None là không sử dụng ma trận footprint , output = None là kết quả được lưu vào b1 , mode='reflect' là cách xử lý biên ảnh các pixel ngoài biên được phản chiếu , cval=0.0 là giá trị hằng, origin = 0 là điểm gốc của kernel ở trung tâm. -> iio.imsave('baby.jpeg', b3): Lưu ảnh đã lọc -> plt.imshow(b3): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.title("Median Filter") : Ghi chủ đề ảnh. -> plt.show() : Mở cửa sở để hiển thị ảnh.

    Kết quả: Max Filter lọc nhiễu tốt nhất, 3 filter còn lại không tốt và nhìn creepy hơn.

Câu 7:
Max Filter

-> a1 = iio.imread('flower.jpeg', mode='L').astype(np.uint8): Sử dụng để python có thể đọc ảnh = grayscale ( model = L) và stype(np.uint8) để giá trị pixel [0,255]. -> b2 = sn.maxium_filter(a1, size=5, footprint=None, output=None, mode='reflect',cval=0.0, origin=0): Sử dụng hàm sn.maxium_filter để thực hiện bộ lọc có lấy giá trị lớn nhất vùng lân cận với a1 là ảnh xám đầu vào, size =5 là kích thước tương ứng là 5x5 pixel, footprint = None là không sử dụng ma trận footprint , output = None là kết quả được lưu vào b1 , mode='reflect' là cách xử lý biên ảnh các pixel ngoài biên được phản chiếu , cval=0.0 là giá trị hằng, origin = 0 là điểm gốc của kernel ở trung tâm. -> iio.imsave('flower1.jpeg', b2): Lưu ảnh đã lọc -> plt.imshow(b2): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.title("Median Filter") : Ghi chủ đề ảnh. -> plt.show() : Mở cửa sở để hiển thị ảnh.
Sobel Filter

    Sử dụng các thư viện cần thiết. -> a = iio.imread('flower1.jpeg', mode='L'): Sử dụng để python có thể đọc ảnh = grayscale. -> b1 = filters.sobel(a).astype(np.uint8): Sử dụng hàm filter.sobel(a) để tiến hành sử dụng bộ lọc Sobel Filter để lọc gradient bậc 1 cùng với kiểu np.uint8 để lấy số nguyên không dấu 8-bit [0,255].

    iio.imsave('flower_laplace_filter_edge_detection.png', b4): Lưu ảnh đã lọc sang một file ảnh với tên mới. -> plt.imshow(b1): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.show() : Mở cửa sở để hiển thị ảnh.

#Prewitt Filter

    Sử dụng các thư viện cần thiết. -> a = iio.imread('flower1.jpeg', mode='L'): Sử dụng để python có thể đọc ảnh = grayscale. -> b2 = filters.prewitt(a).astype(np.uint8): Sử dụng hàm filter.prewitt(a) để tiến hành sử dụng bộ lọc Prewitt Filter để phát hiện biên ảnh cùng với kiểu np.uint8 để lấy số nguyên không dấu 8-bit [0,255].

    iio.imsave('flower_prewitt_filter_edge.png', b2): Lưu ảnh đã lọc sang một file ảnh với tên mới. -> plt.imshow(b2): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.show() : Mở cửa sở để hiển thị ảnh.

Canny Filter

    Sử dụng các thư viện cần thiết. -> a1 = iio.imread('flower1.jpeg', mode='L').astype(np.uint8): Sử dụng để python có thể đọc ảnh = grayscale cùng với kiểu np.uint8 để lấy số nguyên không dấu 8-bit [0,255]. -> b3 = feature.canny(a1, sigma=3).astype(np.uint8): Sử dụng hàm feature.canny để sử dụng các thuật toán xử lý ảnh phát hiện đường biên chính xác, giảm nhiễu có trong ảnh với kiểu np.uint8 để lấy số nguyên không dấu 8-bit [0,255]. -> iio.imsave('flower_canny_filter_edge.png', b3): Lưu ảnh đã lọc sang một file ảnh với tên mới. -> plt.imshow(b3): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.show() : Mở cửa sở để hiển thị ảnh.

Laplacian Filter

    Sử dụng các thư viện cần thiết. -> a = iio.imread('flower1.jpeg', mode='L'): Sử dụng để python có thể đọc ảnh = grayscale. -> b4 = sn.laplace(a, mode='reflect').astype(np.uint8): Sử dụng hàm feature.canny để sử dụng các thuật toán xử lý ảnh phát hiện đường biên chính xác, giảm nhiễu có trong ảnh với kiểu np.uint8 để lấy số nguyên không dấu 8-bit [0,255]. -> iio.imsave('flower_laplace_filter_edge_detection.png', b4): Lưu ảnh đã lọc sang một file ảnh với tên mới. -> plt.imshow(b4): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.show() : Mở cửa sở để hiển thị ảnh.
    Kết quả: Dùng bộ lọc Max Filter để làm nhiễu sau đó test 4 filter lọc biên khác nhau. Sobel Filter không phát hiện được nhiều biên một cách rõ ràng, Prewitt Filter cũng không phát hiện được nhiều biên một cách rõ ràng, Canny Filter thì hiển thị một số đừng viền màu vàng thưa thớt với các đường viền chính của hoa, Laplacian Filter thì thể hiện kết quả đường viền dày đặc cho thấy độ sáng trong ảnh thay đổi rõ rệt bao gồm độ nhiễu, chi tiết nhỏ.

Câu 8:

    Median Filter : -> a1 = iio.imread('balloons_noisy.png', mode='L').astype(np.uint8): Sử dụng để python có thể đọc ảnh = grayscale ( model = L) và stype(np.uint8) để giá trị pixel [0,255]. -> b1 = sn.median_filter(a1, size=5, footprint=None, output=None, mode='reflect',cval=0.0, origin=0): Sử dụng hàm sn.median_filter để thực hiện bộ lọc trung vị với a1 là ảnh xám đầu vào, size =5 là kích thước tương ứng là 5x5 pixel, footprint = None là không sử dụng ma trận footprint , output = None là kết quả được lưu vào b1 , mode='reflect' là cách xử lý biên ảnh các pixel ngoài biên được phản chiếu , cval=0.0 là giá trị hằng, origin = 0 là điểm gốc của kernel ở trung tâm. -> iio.imsave('balloons_noisy1.png', b1): Lưu ảnh đã lọc -> plt.imshow(b1): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.title("Median Filter") : Ghi chủ đề ảnh. -> plt.show() : Mở cửa sở để hiển thị ảnh.

    Đổi ảnh màu RGB: -> img = iio.imread('balloons_noisy1.png') : Đọc ảnh sau khi đã lọc nhiễu. -> if len(img.shape) == 2: / img = np.stack((img, img, img), axis=-1) : Kiểm tra ảnh có màu trắng đen hay không và chuyển thành RGB -> r = np.clip(img[:, :, 0] * np.random.uniform(0.5, 1.5), 0, 255) -> g = np.clip(img[:, :, 1] * np.random.uniform(0.5, 1.5), 0, 255) -> b = np.clip(img[:, :, 2] * np.random.uniform(0.5, 1.5), 0, 255) -> rgb = np.stack((r, g, b), axis=-1).astype(np.uint8) : Màu sắc của RGB sau khi lấy ảnh đã lọc nhiễu để đem đổi màu thuộc màu RGB ngẫu nhiên , sau đó tạo ảnh RGB mới sau khi đã qua chuyển màu RGB. -> iio.imsave('balloons_noisy1_rgb.png', rgb) : Lưu ảnh đã lọc sang một file ảnh với tên mới. -> plt.imshow(rgb): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.title("RGB image") : Ghi chủ đề ảnh. -> plt.show() : Mở cửa sở để hiển thị ảnh.

Câu 9:
Median Filter :

-> a1 = iio.imread('bird.png', mode='L').astype(np.uint8): Sử dụng để python có thể đọc ảnh = grayscale ( model = L) và stype(np.uint8) để giá trị pixel [0,255]. -> b1 = sn.median_filter(a1, size=5, footprint=None, output=None, mode='reflect',cval=0.0, origin=0): Sử dụng hàm sn.median_filter để thực hiện bộ lọc trung vị với a1 là ảnh xám đầu vào, size =5 là kích thước tương ứng là 5x5 pixel, footprint = None là không sử dụng ma trận footprint , output = None là kết quả được lưu vào b1 , mode='reflect' là cách xử lý biên ảnh các pixel ngoài biên được phản chiếu , cval=0.0 là giá trị hằng, origin = 0 là điểm gốc của kernel ở trung tâm. -> iio.imsave('bird1.png', b1): Lưu ảnh đã lọc -> plt.imshow(b1): Sử dụng Matplotlib.pyplot(plt) để vẽ đồ thị và hiển thị ảnh -> plt.title("Median Filter") : Ghi chủ đề ảnh. -> plt.show() : Mở cửa sở để hiển thị ảnh.
HSV:
-> rgb = iio.imread('bird1.png') : Đọc ảnh RGB sau khi đã lọc nhiễu. -> rgb2hsv = np.vectorize(colorsys.rgb_to_hsv) : Tạo hàm xử lý từng pixel cho toàn bộ mảng. -> h,s,v = rgb2hsv(rgb[:,:,0],rgb[:,:,1],rgb[:,:,2]): Tách 3 kênh R, G ,B sang H, S, V -> h *=h : Bình phương giá trị pixel và thay đổi màu tương phản ở vùng màu có tuognw phản thấp -> hsv_new = np.stack((h, s, v), axis=-1) * 255 : gộp lại 3 kênh H, S, V thành ảnh mới dạng HSV, rồi nhân 255 từ [0, 1] về [0, 255]. -> hsv_new = hsv_new.astype(np.uint8) : chuyển đổi hình ảnh HSV mới về kiểu ( 8-bit ) để có thể lưu và xuất. -> iio.imsave('bird1_HSV.png',hsv_new) : Lưu hình ảnh HSV mới nhất. -> plt.imshow(hsv_new) : Xuất ra hình ảnh HSV mới -> plt.title("HSV Image") : Chủ đề ảnh -> plt.show() : Hiện hình ảnh HSV
